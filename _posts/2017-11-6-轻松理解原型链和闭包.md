---
layout: post
title:  "轻松理解原型链、继承和闭包"
categories: JavaScript
tags: JavaScript
excerpt: 几分钟理解原型链、继承和闭包。穿插一点作用域。2017/11/6更新
---

## 一、作用域

> 作用域这个东西说简单，但是又总是容易出点错。这里，我们只讨论一个**提升**。

先甩出一句话：

**包括变量和函数在内的所有声明，都会在任何代码被执行前首先被处理，并且函数首先被提升，然后才是变量。**

### 1.1、小思考

看到**var a = 2**;会想到什么？

一般呢都会认为这个是一个声明，就一个赋值语句，把2赋值给a。

但是，js其实会把他分成两个部分：**var a；和a = 2；。第一个定义声明是在编译阶段进行的，而第二个赋值声明会被留在原地等待执行，即代码执行前就进行了var a。** 

看下面一段代码：
```
console.log(a); // 这里不会报错而是会出现undefined，因为，后面的var a；在编译阶段就已经声明了，此时已经有了a，只是还没给a赋值而已。
var a = 2;
```
再来一段代码
```
1. foo(); // TypeError
2. bar(); // ReferenceError
3.
4. var foo = function() {};

解析：这里第一句是TypeError表明foo已经声明了的，知识foo不是函数，才出现了类型错误，而bar根本没声明。具体理解，就是下面这样

var foo; // 声明被提升到了作用域的顶端

foo(); // 声明的foo没说是个函数，所以这个TypeError
bar();

foo = function() {};
```

由于函数声明和变量声明都会被提升，所以很明显就想到一个问题，到底是哪个会被提升到最上层呢？**其实，函数会首先被提升，然后才是变量**。看代码:

```
foo(); // 输出1。即函数的声明在变量声明前面。

var foo;

function foo() {console.log(1);};
```



## 二、原型

> 提到原型就必须先提到原型对象，而这个原型对象就是理解原型的关键

### 2.1、理解原型对象

> 每一个函数在创建之后都会拥有一个名为**prototype**的属性，这个属性指向函数的**原型对象**。。而，原型对象会获得一个**constructor**属性，这个属性则指向那个构造函数。比如，Person.prototype. constructor措向Person。

**注：通过Function.prototype.bind方法构造出来的函数是个例外，它没有prototype属性**

### 2.2、prototype和_proto_

> prototype为所有的函数都有的，指向这个函数的原型对象。而_proto_为对象实例有的，指向创建这个对象的函数(constructor)的prototype。

**注：Object.prototype 这个对象是个例外，它的__proto__值为null**

### 2.3、原型链

> 由于任何对象都有_proto_属性，所以就会形成一条以_proto_连接的链条，而链条的终端就为Object.prototype它的值为null。下面来个例子：

```
var Person = function(age, sex, name) {
	this.age = age;
	this.sex = sex;
	this.name = name;
};

Person.prototype = {
	"job" : "teacher",
	"load" : function () {
		var a = ++this.age; // 前++，先++再运行表达式
	    return a;
	}
};

var obj1 = new Person(20, "man", "rock");
console.log(obj1.job); // tercher
console.log(obj1.load()); // 21
```

> 分析：首先obj1在他的构造函数里面搜索job属性，结果没有，就只有沿着_proto_向上搜索。就搜索到了Person.prototype，里面有job属性就输出teacher。下面的21也是同理。



## 三、继承

> 前面讲那么多，说到底都是为了这个**继承**来服务的。但是，js中的继承和java等的继承不一样，js的继承不会发生复制，而只是通过内部的_proto_来连接的。


### 3.1、一个简单的继承

> 下面是常用的继承实现方式，用new操作符来创建对象。但是，这样会有一个问题，下面慢慢来讲

```
// 实例的属性写在构造函数里面
1. var People = function(age, sex, name) {
2. 	this.age = age;
3.	this.sex = sex;
4.	this.name = name;
5.	this.color = ["red","blue"];
6. };
7.
8. // 共有属性和函数写在prototype里面
9. People.prototype = {
10.    what: "a",
11.    sayName : function() {}
12. };
13.
14.
15. var Person = function(age) {
16.    People.call(this,age); // 这里在Person的环境中运行People，
17.    this.age = age;
18. }
19.
20. Person.prototype = new People(); // 这里相当于把Person.prototype通过_proto_,关联到People.prototype
21.
22. var aperson = new Person("zhangsan"); // 这里执行Person构造函数

```

> 小解析：(1)20行实现了继承，这行中首先new出来了一个实例，然后把实例赋值给了Person.prototype，此时，Person.prototype就相当于People的一个实例，即，它可以访问People.prototype。他这里并没有发生复制，而只是指向了它。(2)16行通过对call的使用，又相当于继承了父构造函数People的属性。
>
> 问题：这里的20行是通过new操作符来创建一个对象，所以这里就会调用一次People构造函数，而这次可以说是没有意义的.
> 
> 关于这部分的加深内容，请看我的另一篇文章[用对象关联风格的代码来代替类风格代码]()



## 四、闭包

> 闭包其实就是一个函数，不过这个函数可以访问其他作用域的数据。
>
> 一个函数的变量原本应该在这个函数运行结束的时候就摧毁。但是，若这个函数里有一个闭包，那闭包中引用的父函数的变量，就不会再父函数运行结束的时候被摧毁，而是等到闭包被摧毁的时候再摧毁。

### 4.1、例1
**直接上代码**：

```
var parent = function () {
	var alltd = document.getElementsByTagName("td"),
    len = alltd.length;

for (var i =0; i < len; i++) {
	alltd[i].onclick = function() {
		console.log(i);  // 全都为9
}
}
};
parent();
```

> 分析：首先这里有两个函数，一个是外部函数parent，一个是内部的onclick事件处理函数。由于这个事件处理函数是没有定义变量i的，所以这个i是通过作用域链向上查找，在父函数parent中找到的。所以，当父函数被摧毁的时候，i依然会保存着他的最后一个值，即9，所以事件处理函数每次运行的结果都为9.

**现在我们知道了，上面代码出现问题的原因是由于i没有被销毁，使闭包中每次运行的i值都为父函数运行结束时候的值，那么我们只需要让每次的i值等于实际的i值不就好了吗？解决方案如下：**

```
var parent = function () {
	var alltd = document.getElementsByTagName("td"),
    len = alltd.length;

for (var i =0; i < len; i++) {
	(function (num) {
		alltd[num].onclick = function() {
		console.log(num);  
       }
	})(i);
}
};
parent();
```

> 分析：上面代码我们添加了一个自执行函数，然后把i值作为参数传进去，而用形参num来代替i，然后在自执行函数内部都用num来代替i。这样就完美解决了。因为没有在自执行函数内部访问其他作用域的变量，所以这个自执行函数没有产生闭包。而，里面的事件处理函数还是会产生闭包，但是for循环运行一次自执行函数就运行一次，所以num值是会改变的，所以完美解决。

### 4.2、例2

```
var parent = function () {
	var globalNum = 2;
	globalNum++;
	var child = function () {
		globalNum++;
		console.log(globalNum); // 先输出4，再输出5，最后输出6
	}
    return child;
}

var inside = parent();
inside();
inside();
inside();
```

> 分析：首先这里创建了一个闭包child。然后，由于闭包中引用的是父函数的变量globalNum，所以当父函数执行完后globalNum不会被摧毁。父函数执行完后globalNum值为3，然后闭包被调用，globalNum值变为4。此时由于后续还有闭包的调用，所以这个globalNum依然不会被摧毁，同理后来就会输出5，6.