---
layout: post
title:  "js强制类型转换"
categories: JavaScript
tags: JavaScript
excerpt: 本文讨论js中的强制类型转换。很多人觉得强制类型转换很不好，以至于没有深入的了解它，但是本文将讨论强制类型转换的优缺点。
---





前言：强制类型转换可以理解为分为显示和隐式的两种。他们直接的区别是很明显的，显示就是直接可以看到转换了的，隐式就是转换的不明显的。如：

```
var a = 42;
var b = a + ""; // 隐式强制类型转换
var c = String(a); // 显示强制类型转换，这个为用原生函数来进行转换
var d = a.toString(); // 既有显示又有隐式。显示为：toString()的转换，
                                  // 隐式为：刚开始的a是不能直接调用toString()的，它必须经过String()的包装，所以这里，原来的数字a经过包装之后变成了对象，然后再通过方法，变成了字符串。
```

## 一、显示强制类型转换

> 简单来说显示强制类型转换就是进行了我们看的到的操作。比如，用原生函数和各种方法进行的转换等。

#### 一、toString、Number、Boolean

##### 1、toString、String

> 这个就是把其他类型转换为字符串类型。

>+ 数组用toString的时候，是把数组的每个项用逗号拼接起来。如：

```
var arr = [1,2,3];
arr.toString(); // "1,2,3"
```

##### 2、Number

> 这个就是把其它类型转换为数字

>+ true转换为1，false转换为0，undefined转换为NaN，null转换为0，""转换为0.
>
>+ 对象(包括数组)会首先转换为基本类型值（先调用valueOf(),如果没有就调用toString()），如果转换出来的为非数字类型，则再转换。
>
>+ 处理失败返回NaN
>
>+ **注：这个转换为整体转换。即，需要将整个表达式都转换，而不是像parseInt那种可以转换部分。如**
```
var a = 100px;
var b = ["100"];
var c = ["100","200"];
Number(a); // NaN
Number(b); // 100
Number(c); // NaN
```
>+ **isNaN()**: 这个函数内部是先通过Number()转换，然后再判断。如:``isNaN("100");isNaN(true)``这两个都返回**false**，即他认为内部都是数字。原因是内部用Number()把这个字符串和布尔值进行了转换。

##### 3、Boolean

> 这个就是把其他类型转换为true或者false。这里我们讨论一下转换为false的假值。

>+ 假值列表：undefined、null、+0、-0、NaN、"".
>
>+ 空对象{}和空数组[]都为真值

#### 二、字符串和数字之间的显示转换

> 除了上述那么转换，还有一些显示的转换，不急慢慢来看。

##### 1、+运算符

> 提到这个运算符可能很多人可以直接说出它的两个用途：数字运算和字符串拼接。其实，它还有把字符串显示转换为数字这一个作用。看代码：

```
var a = "3.14";
var d = +a; // 这里就是将字符串"3.14"显示转换为数字3.14.
```

>+ 将日期显示转换为数字的时候，常用到这种方法。如：

```
var time = +new Date(); // 这个应该经常在代码中看到吧
// 用其他转换方法，如下
var time = new Date().getTime();
// 不过更加推荐的方法是下面这种，不进行强制类型转换的
var time = Date.now();
```
> 类似的用！可以显示的把值转换为布尔值。常见的用法是！！。

##### 2、parseInt()来转换出数字

> 关于parseInt()首先要明确三点: 1、它是针对字符串的，所以非字符串参数会首先被强制转换为字符串。2、它可以接受第二个参数，来指定一个基数。3、parseInt()是从左到右解析，一般情况下遇到非数字就停止解析。但是有特例。比如遇到0，空格，+，-开始的字符串，它不会停止解析，而是继续往下解析。如``"-00010.1"``会解析成**-10**.

>+ 关于parseInt()的一个坑：

```
parseInt(1/0, 19);  // 输出为18。有点不理解吧，请看下面解析
```
> 首先1/0结果是infinity,所以表达式就变成了parseInt("infinity", 19); , 这时就是处理字符串了。由于第一个字母是i，以19为基数时i为18；而第二个字母n超过了19的限制，所以解析结束。所以，最后就返回了18.

## 二、隐式强制类型转换

#### 一、字符串和数字之间的隐式强制转换

##### 1、+

> + 简单说就是如果其中一个操作数为字符串，或者一个对象可以转换一个字符串出来，则进行字符串拼接；否则，进行数字加法。如：

```
var a = [1,2];
var b = [3,4];

a + b; // 1,23,4


```
**注：对于数组，先把他们都转换为字符串，然后再拼接。先调用valueOf(),若无法得到基本类型再调用toString().**

##### 2、一些操作符 - * / % ++ --  > <

> 上面的这些操作符都可以进行数字的隐式转换.如：
```
if("10" > 9); // true
if("10" > "9") // false.没有转换
var a = "10";
a++; // 11.发生了隐式转换
```
>
> 数字减运算符，两个操作数都需要被转换为数字。首先是转换为字符串，然后再转换为数字。

#### 二、|| 和 &&

> 这两个操作符在另外一些语言中返回true或者false。但是，**在js中他们的返回值是两个操作数的其中一个**。

**注：&&的优先级高于||.所以，``a || b && c``会先执行``b && c``.而||的优先级也高于**？ ：。

>+ ||: 对于||。如果第一个操作数为true，则返回第一个操作数；如果是false，则返回第二个操作数。
>+ &&: 对于&&。如果第一个操作数为true，则返回第二个操作数；如果为false，则返回第一个操作数。
```
var a = 42;
var b = "abc";
var c = null;

a || b; // 42
a && b; // "abc"

c || b; // "abc"
c && b; // null
```

#### 三、宽松相等中的隐式强制类型转换

> 大家应该都知道相等有两种，一种为宽松相等，即 ==，允许在比较中进行强制类型转换；另外一种为严格相等，即 ===，不允许使用强制类型转换。

**注：在这个相等的比较中，往往都要转换成数字。**

##### 1、字符串和数字之间的相等比较

> 他们比较的时候，是把字符串转换为数字，然后进行比较。

##### 2、其他类型与布尔类型之间的相等比较

> 不管其他类型是什么，布尔类型都会首先转换为数字，然后，其他类型也会随着转换为数字来和它比较。如：
```
var a = "42";
var b = true;

a == b; // false.这里b变成了1，而a变成了42，1当然不等于42
```

##### 3、null和undefined之间的相等比较

> null和undefined可以相互转换。**但是，在相等比较的时候，这两个值都不等于其他的假值。如，不等于0、""、false这些。虽然null在toNumber转换的时候可以转换为0**。

##### 4、一些例子

```
0 == null; // false
0 == undefined; // false
0 == NaN; // false

0 == []; // true
0 == {}; // false

0 == ""; // true.空字符串包括"\n"这些，都可以转为0
"" == []; // true.""转为0，[]也转为0
false == ""; // true. false转为0，""也转为

[] == ![]; // true

10 + null; // 10; 由于null的toNumber转换为0，则结果为10
10 + undefined; // NaN; 由于undefined的toNumber转换为NaN，则结果为NaN
```