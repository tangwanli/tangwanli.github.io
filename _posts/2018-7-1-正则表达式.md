---
layout: post
title:  "正则表达式"
categories: JavaScript
tags: JavaScript
autor: rock
---

这篇文章是写正则基础的。




## 一、正则摘要

### 1、正则表达式括号的作用:

>+ <1>限制多选项的范围 ``(Fri|1)st``  这样写会匹配Frist或1st。如果去掉括号，则``Fri|1st``就是匹配 ``Fri或1st``
>
>+ <2>将若干个字符进行组合，受量词的同时作用。例如 th+  表示匹配 th thh thhh(h无数次)，如果是(th)+，则匹配的是th thth ththth(th无数次)
>
>+ <3>捕获组：反向引用，即前面括号匹配到的东西记忆与后面，常用于匹配重复单词。引用的是前面捕获组中的文本而不是正则，也就是说反向引用处匹配的文本应和前面捕获组中的文本相同，这一点很重要
>
>+ 4、非捕获组

### 2、正则表达式一些常用符

**常用元字符**

代码  　　　　　　　　　　说明

>+ **.**  　　　　　　　　　　　　匹配除换行符以外的任意字符
>+ **\w** 　　　　　　　　　　　 匹配字母或数字或下划线或汉字word
>+ **\s** 　　　　　　　　　　　 匹配任意的空白符space character
>+ **\d** 　　　　　　　　　　　 匹配数字digit
>+ **\b** 　　　　　　　　　　　 匹配单词的开始或结束begin
>+ **^**  　　　　　　　　　　　　匹配行的开始
>+ **$**  　　　　　　　　　　　　匹配行的结束

**常用反义元字符**

代码 　　说明

>+ **\W** 　　　　 匹配任意不是字母，数字，下划线，汉字的字符
>+ **\S** 　　 　　  匹配任意不是空白符的字符
>+ **\D** 　　　　　匹配任意非数字的字符
>+ **\B** 　　 　　  匹配不是单词开头或结束的位置
>+ **[^aeiou]** 　　匹配除了aeiou这几个字母以外的任意字符


**常用重复限定符**

>+ *　　　　　　 重复零次或更多次
>+ **+**  　　　　　　　 重复一次或更多次
>+ **?**  　　　　　　　 重复零次或一次
>+ **{n}**  　　　　　　重复n次
>+ **{n,}** 　　　　　  重复n次或更多次
>+ **{n,m}**  　　　　  重复n到m次

**常用修饰符**

> 修饰符可以混合使用，比如：/hello/ig
>+ **i**  　　　　　　　 执行对大小写不敏感的匹配
>+ **g**  　　　　　　　 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）
>+ **m**  　　　　　　执行多行匹配。会识别换行符，如\n这些。就可以用^和$匹配每一行的行首和行尾。
```
var str = "hello world,\nhello world";
// ["hello"]
str.match(/^hello/g);
// ["hello", "hello"]
str.match(/^hello/gm);
```
>+ **u**  　　　　　　es6新增。使.可以识别32位字符
>+ **y**  　　　　　　es6新增。用match匹配的时候，后面的字符串要从第一个开始匹配
>+ **s**  　　　　　　es6新增。使.可以匹配\n这种行终止符

---
## 二、具体解析

### 一、 最易理解的元字符。
 
>+ 脱字符  **^**   ：表示匹配行首的文本
>
>+ 美元符  **$**　：表示匹配行尾的文本
 
**pattern：^cat 　　//　匹配以c作为一行的第一个字符是c，然后是一个a，紧接着一个t的文本**
    
    例如：Regex reg = new Regex("^cat");
    Console.WriteLine(reg.Match("catdog"));     //输出 cat
    Console.WriteLine(reg.Match("dogcat"));    //输出空白(啥都不输出)
    
    Regex reg2 = new Regex("cat$");
    Console.WriteLine(reg2.Match("catdog"));      //输出 空白(啥都不输出)
    Console.WriteLine(reg2.Match("dogcat"));     //输出 cat
    
**特殊正则说明**

>+ **^cat$** 　　　//　匹配行开头是cat，然后就是行末尾的cat，说白了就是一行中仅仅只包含cat的行，没有其他字符。
>
>+ **^$**　　　//　匹配行开头，然后就是行末尾了，说白了就是匹配一个空行(没有任何字符，也没有空白字符)

>+ **^** 　　//　匹配行的开头，每一行都匹配


### 二、 字符组。
 
 >+ **[ ]** 　// 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思
 >
 
     gr[ea]y    // 匹配grey或gray
     // 　其中连字符 - 表示一个范围，例如[1-6]与 [123456]的作用一致。其他类似的还有[a-z]，[A-Z]。
     例如: Regex reg = new Regex("<h[1-6]>");
     string str = "<div><h1>你在他乡还好吗？</h1></div>";
     Console.WriteLine(reg.Match(str));      //输出 <h1>
     特别强调：只有在字符组内部连字符 - 才是元字符，否则它就只匹配普通的连字符 - 。
 
### 三、 排除型字符组。
 
>+ [^...]　//　[^...]表示匹配所有方括号里未列出的字符
>
   
    r[^abc]r　　// 匹配出rar,rbr,rcr之外的任意r*r文本
    Regexp reg = new Regexp("a[^123]");
    Console.WriteLine(reg.Match("a1a2a3a4")); //输出 a4
    特别强调：在[]里面是没有元字符的，都代表本身的含义，例如[.]就表示匹配一个点.的意思。
    
### 四、 点号.匹配任意字符

### 五、多选结构(或)

  >+ **|**　//　或 多选分支    选择两者中的一个    注意|将左右两边分为两部分，而不管左右两边有多长多乱
```
    gray|grey    //既可匹配gray又可匹配grey    相当于gr[ae]y
```
    
### 六、重复出现

**下面三个字符都代表可选项，把他加在一个字符的后面，就表示此处容许出现这个字符**

>+ ?　// 跟在一个字符后面，容许此字符出现0次或1次   
>+ **+**　// 跟在一个字符后面，容许此字符至少出现1次，可以出现无数次  
>+ \*　// 跟在一个字符后面，容许此字符出现0次或无数次
>+ {min,max}　　// 大括号内的数字用于表示某字符允许出现的次数区间。

```
    colou?r    //可以匹配colour或color
    Regex reg2 = new Regex(@"colo{3,5}r");
    Console.WriteLine(reg2.Match("coloor"));    //输出 空白(啥都不输出)  至少3个，但是字符串里只有两个，因此不符合
```
    
### 七、正则表达式高级用法(分组与捕获)

> 分组的引入：对于要重复单个字符，非常简单，直接在字符后卖弄加上限定符即可，例如 a+ 表示匹配1个或一个以上的a，a?表示匹配0个或1个a。如果要对多个字符进行重复怎么办呢？此时我们就要用到分组，我们可以使用小括号"()"来指定要重复的子表达式，然后对这个子表达式进行重复，例如：(abc)? 表示0个或1个abc 这里一 个括号的表达式就表示一个分组 。
>+  分组可以分为两种形式，**捕获组和非捕获组**。
 
 #### 一、捕获组（普通捕获组）
 
**(1)捕获组编号**：捕获组可以通过从左到右计算其开括号来编号。如：

```
    表达式 (A)(B(C)).* 中，存在四个这样的组：
    0 　(A)(B(C)).* // 零组始终代表整个表达式
    1   (A) 
    2   (B(C))
    3   (C)
    另：(?< name>Expression)为命名捕获组，目前只有.NET、PHP、Python等部分语言支持。
```

  **之所以这样命名捕获组是因为在匹配中，保存了与这些组匹配的输入序列的每个子序列。捕获的子序列稍后可以通过 Back 引用（反向引用） 在表达式中使用，也可以在匹配操作完成后从匹配器检索。**
  
```
    例如：  (\d{1,3}).*\1  // 后面的\1就是对第一个分组的引用
    第0组为  (\d{1,3}).*\1  
    第一次组为 (\d{1,3}) // 只不过\1不是匹配前面的那个正则表达式，而是匹配前面正则表达式筛选出来的字符串
```

**注：反向引用，引用的是前面捕获组中的文本而不是正则，也就是说反向引用处匹配的文本应和前面捕获组中的文本相同，这一点很重要。**

#### 二、非捕获组

**(1)定义**：以 (?) 开头的组是纯的非捕获 组，它不捕获文本 ，也不针对组合计进行计数。就是说，如果小括号中以?号开头，那么这个分组就不会捕获文本，当然也不会有组的编号，因此也不存在Back 引用。
  
**1、非捕获组(?:Pattern)：这个括号中的字符会出现在匹配结果中。**
  
>+ 它的作用就是匹配Pattern字符，好处就是不捕获文本，不将匹配到的字符存储到内存中，从而节省内存。**在不需要捕获的时候，应当尽可能用非捕获组**
>
>+ 例：(?:a|A)123(?:b)可以匹配结果：a123b或者A123b

**2、断言：断言只是起一个挑选作用，括号中的文本不会出现在挑选结果中。相当于一个限制条件。**
    
>+ **(?= X )**：先行断言。仅当**与表达式 X 匹配的表达式在** 这个断言的**左侧**时才继续匹配。也就是说要使此断言起到我们想要的效果的话，就必须把这个非捕获组放在整个表达式的右侧。例如，/w+(?=/d) 与后跟数字的单词匹配，而不与该数字匹配。此构造不会回溯。
>
>+ **(?! X )**：先行否定断言。仅当**与表达式 X 匹配的表达式不在** 这个断言的**左侧**时才继续匹配。例如，例如，/w+(?!/d) 与后不跟数字的单词匹配，而不与该数字匹配 。
>
>+ **(?<= X )**：后行断言。仅当**与表达式 X 匹配的表达式在** 这个断言的**右侧**时才继续匹配。例如，(?<=19)99 与跟在 19 后面的 99 的实例匹配。此构造不会回溯。
>
>+ **(?<! X )**：后行否定断言。仅当**与表达式 X 匹配的表达式不在** 这个断言的**右侧**时才继续匹配。例如，(?<!19)99 与不跟在 19 后面的 99 的实例匹配


> 例子：
```
 (1) 正则表达式 (?<!4)56(?=9) // 
 这个表达式最后的返回结果还是为56
含义：匹配后面的文本56前面不能是4，后面必须是9组成。因此，可以匹配如下文本 5569  ，与4569不匹配。
(2) 提取字符串 da12b ka3434bd ca4343bd中包含在字符a和b之间的数字，
但是这个a之前的字符不能是c；b后面的字符必须是d才能提取。
正则表达式：(?<=[^c]a)\d*(?=bd)
挑选结果为：3434 
```
    
    
##### 3、RegExp构造函数

> 用这个构造函数可以构造出来正则表达式。有两种接收参数的形式，第一种为第一个参数为字符串，第二个为修饰符。**第二种形式为第一个参数为一个正则表达式，es5不允许在加上第二个修饰符参数，而es6中第二个修饰符参数会覆盖原有的修饰符**。
```
var regex = new RegExp('xyz', 'i');
// 等价于
var regex = /xyz/i;
// flags为es6新增属性，表明现在的修饰符
new RegExp(/abc/ig, 'i').flags; // i
```


##### 4、正则表达式需要转义的字符

```
* . ? + $ ^ [ ]() { } | \ /
```
##### 5、正则表达式中的方法

> String对象的方法

>+ (1)**string.search(regexp)**: 返回该字符串中第一个与regexp对象相匹配的子串的起始位置。如果没有找到任何匹配的子串，则返回-1；**且search()方法不执行全局匹配，它将忽略标志g**
```
var str = "hello world,hello world";
str.search(/hello/);  // 0
```
>+ (2)**string.match(regexp)**: **返回匹配成功的值的数组; 不全局匹配的数组**有三个元素，第一个元素的存放的是匹配的文本，第二个为index属性表明的是匹配文本的起始字符在string中的位置，第三个为input属性声明的是对string对象的引用。**全局匹配的数组，就只保存所有匹配到的文本**
```
var str = "hello world,hello world";
// ["hello", index: 0, input: "hello world,hello world", groups: undefined]
str.match(/hello/);
// ["hello", "hello"]
str.match(/hello/g);
```
>+ (3)**string.replace(value,replacement)**: 这个方法返回一个新的字符串。第一个参数可以是一个字符串，也可以是一个正则表达式。**第一个参数为字符串的时候，直接将string中出现的这个字符串替换为第二个参数的那个字符串(只不过只替换第一个)。第一个参数是正则表达式的时候，第二个参数可以是一个字符串也可以是一个函数**。
>   + (1)**如果第二个参数是一个字符串**：则直接**用这个字符串来替换**正则表达式匹配到的结果。
>   + (2)**如果第二个参数是一个函数：则用函数的返回值来替换**匹配到的结果。函数**可以接收N个参数**
```
// 第一个参数为正则表达式匹配到的字符
// 第二个参数到第n个参数为：每个分组中捕获的字符，一个分组为一个参数，没有分组则没有这个参数
// 倒数第二个参数：正则每段匹配 的第一个字母的索引
// 最后一个参数：用于匹配的字符串
var str = '12-a2A-b2A',
    reg = /-(\w{2})(A)/g;
var ret = str.replace(reg,function(a,b,c,d,e){console.log(a,b,c,d,e);return a.toUpperCase();});
console.log(ret,str);
// -a2A a2 A 2 12-a2A-b2A
// -b2A b2 A 6 12-a2A-b2A
// 12-A2A-B2A 12-a2A-b2A
```
>+ (4)**string.split(reg)**: 这个split()方法可以以字符串或者正则作为参数。当参数为正则的时候，就以正则匹配到的那个字符串作为分隔符。

> RegExp对象方法

>+ (1)**reg.test(str)**: 返回true或者false。
```
var str = "hello world,hello world";
/hello/.test(str); // true
```
>+ (2)**reg.exec(str)**: 返回的和match()方法返回的是一样的。
     
     